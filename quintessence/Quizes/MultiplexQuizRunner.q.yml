properties:


  - name: question_pool
    type: std::vector<Quizes::MultiplexQuestion>
    init_with: ''


functions:


  - name: initialize
    body: |
      //std::string QUIZ_FILE = "/Users/markoates/Repos/me/quizes/discover_canada/csv/Canada Flash Cards - Capitals.tsv";
      std::string QUIZ_FILE = "/Users/markoates/Repos/me/quizes/discover_canada/csv/Canada Flash Cards - Provinces-P2.tsv";
      std::string file_contents = get_file_contents(QUIZ_FILE);

      Quizes::MultiplexSheetLoader loader(file_contents);
      loader.load();
      question_pool = loader.get_questions();
      return;
    body_dependency_symbols:
      - Quizes::MultiplexSheetLoader


  - name: run
    body: |
      initialize();

      Quizes::MultiplexQuestionCollectionHelper collection_helper(question_pool);
      std::vector<Quizes::MultiplexQuestion> date_questions = collection_helper.select_with_relevance();

      std::string QUIZ_YAML_OUTPUT_FILE =
         "/Users/markoates/Repos/me/quizes/discover_canada/csv/multiplex_output.yml";
      std::string yaml_formatted = format_for_quiz_yaml_relevance(date_questions);
      write_file_contents(QUIZ_YAML_OUTPUT_FILE, yaml_formatted);
      

      return;
    body_dependency_symbols:
      - Quizes::MultiplexQuestionCollectionHelper
      - std::cout


  - name: format_for_quiz_yaml_date
    type: std::string
    parameters:
      - name: questions
        type: std::vector<Quizes::MultiplexQuestion>
        default_argument: '{}'
    body: |
      std::stringstream output;
      output << "questions:" << std::endl;
      for (auto &question : questions)
      {
         std::string subject = sanitize_quotes(question.get_subject());
         std::string reference_page = sanitize_quotes(question.get_reference_page());
         std::string date = sanitize_quotes(question.get_date());

         output << "  \"" << subject << " (page " << reference_page << ")\":" << std::endl;
         output << "    - \"" << date << "\"" << std::endl;
         output << std::endl;
         output << "  \"" << date << " (page " << reference_page << ")\":" << std::endl;
         output << "    - \"" << subject << "\"" << std::endl;
         output << std::endl;
      }
      return output.str();
    body_dependency_symbols:
      - std::stringstream


  - name: format_for_quiz_yaml_relevance
    type: std::string
    parameters:
      - name: questions
        type: std::vector<Quizes::MultiplexQuestion>
        default_argument: '{}'
    body: |
      std::stringstream output;
      output << "questions:" << std::endl;
      for (auto &question : questions)
      {
         std::string subject = sanitize_quotes(question.get_subject());
         std::string reference_page = sanitize_quotes(question.get_reference_page());
         std::vector<std::string> relevance_options = split_trim_and_shuffle_by_semicolon(sanitize_quotes(question.get_relevance()));
         std::string relevance = Blast::StringJoiner(relevance_options, "; ").join();

         output << "  \"" << subject << " (page " << reference_page << ")\":" << std::endl;
         output << "    - \"" << relevance << "\"" << std::endl;
         output << std::endl;
         output << "  \"" << relevance << " (page " << reference_page << ")\":" << std::endl;
         output << "    - \"" << subject << "\"" << std::endl;
         output << std::endl;
      }
      return output.str();
    body_dependency_symbols:
      - std::stringstream


  - name: write_file_contents
    parameters:
      - name: filename
        type: std::string
        default_argument: "\"\""
      - name: file_contents
        type: std::string
        default_argument: "\"\""
    body: |
      std::ofstream out(filename);
      out << file_contents;
      out.close();
    body_dependency_symbols:
      - std::ofstream


  - name: get_file_contents
    type: std::string
    parameters:
      - name: filename
        type: std::string
        default_argument: '"no-file.txt"'
    body: |
      std::ifstream t(filename);
      std::string str((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());
      return str;
    body_dependency_symbols:
      - file_loading_deps


  - name: sanitize_quotes
    type: std::string
    parameters:
      - name: str
        type: std::string
        default_argument: '""'
    body: |
      std::size_t n = str.length();
      std::string escaped;
      escaped.reserve(n * 2);        // pessimistic preallocation
      for (std::size_t i = 0; i < n; ++i) {
          if (str[i] == '\\' || str[i] == '\"' || str[i] == '\'')
              escaped += '\\';
          escaped += str[i];
      }
      return escaped;


  - name: split_trim_and_shuffle_by_semicolon
    type: std::vector<std::string>
    parameters:
      - name: str
        type: std::string
        default_argument: '""'
    body: |
      std::vector<std::string> tokens = Blast::StringSplitter(str, ';').split();

      for (auto &token : tokens)
      {
         token = trim(token);
      }
 
      std::random_device rng;
      std::mt19937 urng(rng());
      std::shuffle(tokens.begin(), tokens.end(), urng);

      return tokens;
    body_dependency_symbols:
      - random_shuffling_deps
      - Blast::StringSplitter
      - Blast::StringJoiner


  - name: trim
    type: std::string
    parameters:
      - name: str
        type: std::string
        default_argument: '""'
    body: |
      return Blast::String::Trimmer(str).trim();
    body_dependency_symbols:
      - Blast::String::Trimmer


dependencies:


  - symbol: random_shuffling_deps
    headers: [ ctime, random ]
  - symbol: file_loading_deps
    headers: [ string, fstream, streambuf ]
  - symbol: std::vector<Quizes::MultiplexQuestion>
    headers: [ vector, Quizes/MultiplexQuestion.hpp ]
  - symbol: Blast::String::Trimmer
    headers: [ Blast/String/Trimmer.hpp ]
  - symbol: Quizes::MultiplexSheetLoader
    headers: [ Quizes/MultiplexSheetLoader.hpp ]
  - symbol: Quizes::MultiplexQuestionCollectionHelper
    headers: [ Quizes/MultiplexQuestionCollectionHelper.hpp ]
  - symbol: Blast::StringSplitter
    headers: [ Blast/StringSplitter.hpp ]
  - symbol: Blast::StringJoiner
    headers: [ Blast/StringJoiner.hpp ]
  - symbol: std::ofstream
    headers: [ fstream ]


